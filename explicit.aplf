∇ exp ← explicit imp
     ns ← ⎕NS''

     {⍎'ns.',⍵,'←''',⍵,''''}¨⎕A

     {⍎'ns.',⍵,'←{}'}¨⎕c⎕a


     :Trap 0 ⋄ expr ← ns⍎imp ⋄ :EndTrap

     f∆ ← '!*+,-/<=>?\|~×÷↑↓∊∧∨∩∪≠≡≢≤≥⊂⊃⊆⊖⊤⊥⌈⌊⌷⌹⌽⌿⍀⍉⍋⍎⍒⍕⍟⍪⍱⍲⍳⍴⍷⍸○'

     o⍙ ← '&./@[\¨∘⌶⌸⌺⌿⍀⍠⍣⍤⍥⍨'

     s∆ ← 2031⌶7
     s⍙ ← '⎕OPT' '⎕R' '⎕S'

     op    ← 4
     train ← 3.3
     dfn   ← 3.2
     fn    ← 3
     arr   ← 2

     ∆v  ← 900⌶
     ∆xr ← 183⌶

     Src  ← 62 ⎕ATX⊢
     Form ← 42 ⎕ATX⊢
     Role ← 40 ⎕ATX⊢

     idioms ← '{0}¨' '⊃∘⍴¨' ',/' '⍪/',,'⊣⊢'∘.,'/⌿'

     Dfn  ← {('('≡⊣/⍵)∧')'≡⊢/⍵ : '{}'@((⊢∨⌽)⍷⍨)⍵ ⋄ '{',⍵,'}'}
     Pad  ← '(',,∘')'

     _Apply ← {
        ⍺←⊢
        (Pad⍣(⍬≢⍵))(⍺),(⊃⊆Src '⍺⍺'),(⍵)
        ⍺⍺
      }

     _Op ← {
       ((1=1⊥'_Apply'⍷∊)>1⊥'∆⍙'∊∊)Src '⍺⍺' : ⍺⍺ ⍬
            arr=Role '⍺⍺' : ⍺⍺
        ⍵∧train=Form '⍺⍺' : Dfn '⍺' ⍺⍺ '⍵'
        ⍵<train=Form '⍺⍺' : Dfn     ⍺⍺ '⍵'
        ⍺⍺ ⍬
      }

     _Poke  ← {0::0 ⋄ f←⍎⍵ ⋄ ⍺⍺'f'}

     Cover ← {
         0≠≡⍺ : ⍺ ∇¨ ⍵

         idioms∊⍨⊆∊⍵ : (,¨o⍙) (⊢ ∇⍨¨ 3+∊⍨) ,¨⊃,⍥⊆/(⊢⊂⍨(¯1↓0,=∘'}')∨⍷⍨)∊⍵

         ⍺=arr : '(1 repObj ',(repObj ⍵),')'

         n ← ⊃⊆⍵
         '⎕'=1↑n : '∆',(1↓n)

         dfn≡(Form)_Poke n:'(',n,'_Apply)'
         ⍺=op:'⍙',⍕⎕UCS n
         ⍺=fn:'∆',⍕⎕UCS n
     }

     s∆_n ← {'∆',(1↓⍵)}¨s∆
     s⍙_n ← {'∆',(1↓⍵)}¨s⍙
     f∆_n ← '∆',∘(⍕⎕UCS)¨f∆

     (s∆_n,f∆_n){⍎⍺,'←{                 ⍺←⊢ ⋄ (Pad⍣(⍬≢⍵)) ⍺,               ''',⍵,''',           ⍵}'}¨s∆,f∆
          (s⍙_n){⍎⍺,'←{v ← ×Role''⍺'' ⋄ ⍺←⊢ ⋄ (Pad⍣(⍬≢⍵)) ⍺,(Pad (⍺⍺_Op v),''',⍵,''',(⍵⍵_Op v)),⍵}'}¨s⍙

     ∆8866 ← {⍺←⊢ ⋄ ⍵≡⍬:'⊢' ⋄ ⍺⊢⍵ }
     ∆8867 ← {⍺←⊢ ⋄ ⍵≡⍬:'⊣' ⋄ ⍺⊣⍵ }

     syntax ← 2
     index  ← 3
     rank   ← 4
     length ← 5
     value  ← 6

     THROW ← {
        ⍵≡'strict' : ⎕SIGNAL 1⊆('EN' syntax)('Message' 'The function does not take a left argument')
     }


     _Assign_ ← {⍎(⍺,⍕⎕UCS ⍵),⍺⍺,⍵,⍵⍵}

     '⍙'('←{                 ⍺←⊢              ⋄ (Pad⍣(⍬≢⍵)) ⍺,(Pad (⍺⍺_Op 1),'''_Assign_'''),           ⍵}')¨'/⌸⌿'
     '⍙'('←{v ← ×Role''⍺'' ⋄ ⍺←⊢              ⋄ (Pad⍣(⍬≢⍵)) ⍺,(Pad (⍺⍺_Op v),'''_Assign_'''),           ⍵}')¨'&¨⌶'
     '⍙'('←{  1≡×Role''⍺'' : THROW ''strict'' ⋄ (Pad⍣(⍬≢⍵))   (Pad (⍺⍺_Op 1),'''_Assign_'''),           ⍵}')¨'\⍀'
     '⍙'('←{v ← ×Role''⍺'' ⋄ ⍺←⊢              ⋄ (Pad⍣(⍬≢⍵)) ⍺,(Pad (⍺⍺_Op v),'''_Assign_''' ,(⍵⍵_Op v)),⍵}')¨'@⍠'



     ⍙46   ← { Pad ⍺,(Pad (⍺⍺_Op 1),'.',(⍵⍵_Op 1)),⍵ }
     ⍙9018 ← { 1≡×Role'⍺': THROW 'strict' ⋄ Pad   (Pad (⍺⍺_Op 1),'⌺',(⍵⍵_Op 1)),⍵ }

     ⍙9059 ← {
        v ← ×Role'⍺'
        ⍺←⊢
        '¯1'≡⍵⍵,⍬ : Pad ⍺,(Pad (⍺⍺ ⍬)   ,'⍣',(⍵⍵)     ),⍵
                    Pad ⍺,(Pad (⍺⍺_Op v),'⍣',(⍵⍵_Op v)),⍵
     }

     ⍙91 ← {
        v ← ×Role'⍺'
        ⍺←⊢
        arr ≠ Role '⍵⍵' : ⎕SIGNAL syntax
        Pad ⍺,(Pad (⍺⍺_Op v),'[',⍵⍵,']'),⍵
      }

     ⍙9060 ← {
         v ← ×Role'⍺'
         ⍺←⊢
         ⍵≡⍬: (⍺⍺,⍬),'⍤',(⍵⍵,⍬)
         arr=Role '⍺⍺' : ⎕SIGNAL syntax
         arr=Role '⍵⍵' : Pad ⍺,(Pad(⍺⍺_Op v),'⍤',⍵⍵),⍵
         ⍺⍺ ⍺ ⍵⍵ ⍵
     }

     ⍙8728 ← {
         v ← ×Role'⍺'
         ⍺←⊢
         ⍵≡⍬: (⍺⍺,⍬),'∘',(⍵⍵,⍬)
         r ← arr=Role '⍺⍺'
         l ← arr=Role '⍵⍵'
           l∧r : ⎕SIGNAL syntax
         v∧l∨r : THROW 'strict'
         r : ⍺⍺ ⍵⍵  ⍵
         l : ⍵  ⍺⍺ ⍵⍵
         ⍺ ⍺⍺ ⍵⍵ ⍵
      }

     ⍙9061 ← {
         ⍺ ← {⍵ ⋄ ⍺⍺}
         ⍵≡⍬: (⍺⍺,⍬),'⍥',(⍵⍵,⍬)
         arr=Role '⍺⍺' : ⎕SIGNAL syntax
         arr=Role '⍵⍵' : ⎕SIGNAL syntax
         (⍵⍵ ⍺) ⍺⍺ (⍵⍵ ⍵)
      }

     ⍙9064 ← {
         v ← ×Role'⍺'
         ⍺←⍵
         ⍵≡⍬: (⍺⍺,⍬),'⍨'
         arr≠Role '⍺⍺' : ⍵ (⍺⍺⊣⊢) ⍺
         v∧'⍺⍺'≡⍺⍺ : (v⍴⍺),'(⍺⍺⍨)',⍵
      }

     ∆Outer ← {0=Role '⍺': ∘.×'' ⋄ Pad ⍺,(Pad '∘.',(⍺⍺_Op 1)),⍵}

     :If 0∊⍴⎕nr'expr'
        v1 v2 ← 2⍴⊂'SYNTAX ERROR'
      :Else
           tree ← (∆xr Cover ⎕nr)'expr'
           tree ← { 2≥|≡⍵ : { 1 1 0≡⍵∊'∆⍙',∘(⍕⎕UCS)¨'∘.': (⊢/⍵) '∆Outer' ⋄ ⍵ } ⍵ ⋄ ∇¨⍵ }tree
           tree ←  ⍕{(1=≡)⍵ : ⍵ ⋄ Pad(∇¨⍵)}tree

        f ← ⍎tree
        :If 4.3 4.2 ∨.≡ Form 'f' ⋄ g ← '⍺⍺'f ⋄ :Else ⋄ g ← f ⋄ :EndIf

        :Trap 0
            v1←Dfn(g)'⍵'
        :Else
            v1←⎕DMX.(Message{⍵,⍺,⍨': '/⍨×≢⍺}⎕EM EN)
        :EndTrap

        :Trap 0
            v2←Dfn'⍺'(g)'⍵'
        :Else
            v2←⎕DMX.(Message{⍵,⍺,⍨': '/⍨×≢⍺}⎕EM EN)
        :EndTrap

     :EndIf

     exp ← v1 v2
∇
